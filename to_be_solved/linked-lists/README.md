# Linked List Problems

## Easy Problems
1. **Reverse Linked List** - Reverse a singly linked list iteratively and recursively
2. **Merge Two Sorted Lists** - Merge two sorted linked lists into one sorted list
3. **Linked List Cycle** - Detect if linked list has a cycle using Floyd's algorithm
4. **Remove Duplicates from Sorted List** - Remove duplicates from sorted linked list
5. **Intersection of Two Linked Lists** - Find node where two linked lists intersect
6. **Middle of the Linked List** - Find middle node using slow/fast pointers
7. **Palindrome Linked List** - Check if linked list is palindrome
8. **Remove Linked List Elements** - Remove all nodes with given value

## Medium Problems
1. **Add Two Numbers** - Add two numbers represented as linked lists
2. **Remove Nth Node From End** - Remove nth node from end in one pass
3. **Swap Nodes in Pairs** - Swap every two adjacent nodes
4. **Rotate List** - Rotate list to the right by k places
5. **Partition List** - Partition list around value x
6. **Sort List** - Sort linked list using merge sort
7. **Linked List Cycle II** - Find start node of cycle in linked list
8. **Copy List with Random Pointer** - Deep copy list with random pointers

## Hard Problems
1. **Reverse Nodes in k-Group** - Reverse every k consecutive nodes
2. **Merge k Sorted Lists** - Merge k sorted linked lists efficiently
3. **Design Linked List** - Implement singly or doubly linked list
4. **LRU Cache** - Implement LRU cache using doubly linked list

## Key Patterns
- **Two Pointers (Slow/Fast)**: Cycle detection, finding middle
- **Dummy Node**: Simplifies edge cases in merge/insertion operations
- **Three Pointers**: For reversing (prev, curr, next)
- **Stack**: For palindrome checking, reversing operations
- **HashMap**: For cycle detection, copying with random pointers

## Common Techniques
- Use dummy head to handle edge cases
- Draw diagrams to visualize pointer movements
- Handle null pointer cases carefully
- Consider both iterative and recursive approaches