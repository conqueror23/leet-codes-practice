# Tree Problems

## Binary Tree - Easy Problems
1. **Maximum Depth of Binary Tree** - Find maximum depth using DFS/BFS
2. **Invert Binary Tree** - Invert/flip binary tree
3. **Symmetric Tree** - Check if tree is mirror of itself
4. **Same Tree** - Check if two trees are identical
5. **Binary Tree Inorder Traversal** - Traverse tree inorder iteratively/recursively
6. **Binary Tree Postorder Traversal** - Traverse tree postorder
7. **Binary Tree Preorder Traversal** - Traverse tree preorder
8. **Minimum Depth of Binary Tree** - Find minimum depth to leaf
9. **Balanced Binary Tree** - Check if tree is height-balanced
10. **Diameter of Binary Tree** - Find diameter (longest path between nodes)

## Binary Search Tree - Easy/Medium
1. **Validate Binary Search Tree** - Check if tree is valid BST
2. **Search in Binary Search Tree** - Search for value in BST
3. **Insert into Binary Search Tree** - Insert value maintaining BST property
4. **Convert Sorted Array to BST** - Build height-balanced BST from sorted array
5. **Minimum Absolute Difference in BST** - Find minimum difference between nodes
6. **Range Sum of BST** - Sum values in given range
7. **Two Sum IV - Input is BST** - Find if two nodes sum to target
8. **Kth Smallest Element in BST** - Find kth smallest value
9. **Delete Node in BST** - Delete node maintaining BST property
10. **Trim Binary Search Tree** - Trim BST to given range

## Medium/Hard Problems
1. **Binary Tree Level Order Traversal** - Level-order traversal using BFS
2. **Construct Binary Tree from Preorder/Inorder** - Build tree from traversals
3. **Path Sum** - Check if root-to-leaf path sums to target
4. **Binary Tree Right Side View** - Get rightmost nodes at each level
5. **Lowest Common Ancestor** - Find LCA of two nodes
6. **Serialize and Deserialize Binary Tree** - Convert tree to/from string
7. **Binary Tree Maximum Path Sum** - Find maximum path sum
8. **Recover Binary Search Tree** - Fix BST with two swapped nodes
9. **Unique Binary Search Trees** - Count structurally unique BSTs

## Key Patterns
- **DFS (Depth-First Search)**: Recursively process nodes
- **BFS (Breadth-First Search)**: Level-order processing
- **Divide and Conquer**: Split problem into subproblems
- **Backtracking**: Explore paths and backtrack
- **Morris Traversal**: O(1) space traversal

## Common Techniques
- Use recursion for tree problems (base case + recursive case)
- Consider both recursive and iterative approaches
- Use queue for BFS, stack for DFS iterations
- Handle null nodes carefully
- Draw tree structures to visualize problems