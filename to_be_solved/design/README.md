# Design Problems

## Data Structure Design
1. **Design Linked List** (#706) - Implement singly or doubly linked list
2. **Design HashMap** (#706) - Hash map from scratch with collision handling
3. **Design HashSet** (#705) - Hash set implementation
4. **Min Stack** (#155) - Stack supporting minimum element in O(1)
5. **Max Stack** (#716) - Stack supporting maximum element operations

## Cache Design
1. **LRU Cache** (#146) - Least Recently Used cache with get/put in O(1)
2. **LFU Cache** (#460) - Least Frequently Used cache
3. **Design In-Memory File System** (#588) - File system with directories
4. **All O(1) Data Structure** (#432) - Insert, delete, get random in O(1)

## Iterator Design
1. **Design Iterator** - Iterator for various data structures
2. **Peeking Iterator** (#284) - Iterator with peek functionality
3. **Zigzag Iterator** (#281) - Alternate between two lists
4. **Binary Search Tree Iterator** (#173) - In-order BST traversal iterator

## Queue/Stack Design
1. **Implement Queue using Stacks** (#232) - Queue using two stacks
2. **Implement Stack using Queues** (#225) - Stack using queues
3. **Design Circular Queue** (#622) - Circular queue implementation
4. **Design Circular Deque** (#641) - Double-ended circular queue

## System Design
1. **Design Twitter** (#355) - Social media feed system
2. **Design TinyURL** (#535) - URL shortening service
3. **Design Search Autocomplete** (#642) - Autocomplete system with ranking
4. **Design Log Storage** (#635) - Log storage and retrieval system

## Game Design
1. **Design Tic-Tac-Toe** (#348) - Efficient tic-tac-toe game
2. **Design Snake Game** (#353) - Snake game mechanics
3. **Design Hit Counter** (#362) - Count hits in past 5 minutes
4. **Design Phone Directory** (#379) - Phone number assignment system

## Stream Processing
1. **Moving Average from Data Stream** (#346) - Sliding window average
2. **Find Median from Data Stream** (#295) - Maintain median with heaps
3. **Design Most Recent Used Queue** - Track recent usage patterns
4. **Serialize and Deserialize Binary Tree** (#297) - Tree serialization

## Advanced Design
1. **Design Add and Search Words** (#211) - Trie with wildcard search
2. **Design Word Dictionary** (#720) - Word building system
3. **Design Expression Tree** - Parse and evaluate expressions
4. **Design Spreadsheet** - Basic spreadsheet functionality

## Distributed System Concepts
1. **Design Distributed Cache** - Multi-node caching system
2. **Design Rate Limiter** - API rate limiting
3. **Design Consistent Hashing** - Load balancing algorithm
4. **Design Message Queue** - Asynchronous message processing

## Key Design Principles
- **Single Responsibility**: Each component has one purpose
- **Interface Segregation**: Clean, minimal interfaces
- **Encapsulation**: Hide internal implementation details
- **Modularity**: Separate concerns into modules
- **Scalability**: Design for growth and performance
- **Trade-offs**: Balance time/space complexity

## Common Patterns
- **Builder Pattern**: Complex object construction
- **Observer Pattern**: Event notification system
- **Strategy Pattern**: Interchangeable algorithms
- **Template Method**: Define algorithm skeleton
- **Decorator Pattern**: Add functionality dynamically

## Performance Considerations
- **Time Complexity**: Optimize for frequent operations
- **Space Complexity**: Memory usage vs. performance trade-offs
- **Concurrency**: Thread safety and synchronization
- **Caching**: Store frequently accessed data
- **Lazy Loading**: Load data when needed